// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// REST API for Custodial Battery which provides gas to different networks to help execute transactions.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Get a payload for further token receipt
    ///
    /// - Remark: HTTP `GET /tonconnect/payload`.
    /// - Remark: Generated from `#/paths//tonconnect/payload/get(getTonConnectPayload)`.
    public func getTonConnectPayload(_ input: Operations.getTonConnectPayload.Input) async throws
        -> Operations.getTonConnectPayload.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getTonConnectPayload.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/tonconnect/payload", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTonConnectPayload.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getTonConnectPayload.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Account verification and token issuance
    ///
    /// - Remark: HTTP `POST /tonconnect/proof`.
    /// - Remark: Generated from `#/paths//tonconnect/proof/post(tonConnectProof)`.
    public func tonConnectProof(_ input: Operations.tonConnectProof.Input) async throws
        -> Operations.tonConnectProof.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.tonConnectProof.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/tonconnect/proof", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tonConnectProof.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.tonConnectProof.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns information about the current status of Battery Service.
    ///
    /// - Remark: HTTP `GET /status`.
    /// - Remark: Generated from `#/paths//status/get(getStatus)`.
    public func getStatus(_ input: Operations.getStatus.Input) async throws -> Operations.getStatus.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getStatus.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/status", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStatus.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Status.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns information about Battery Service.
    ///
    /// - Remark: HTTP `GET /config`.
    /// - Remark: Generated from `#/paths//config/get(getConfig)`.
    public func getConfig(_ input: Operations.getConfig.Input) async throws -> Operations.getConfig.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/config", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getConfig.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Config.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns information about a user's balance.
    ///
    /// - Remark: HTTP `GET /balance`.
    /// - Remark: Generated from `#/paths//balance/get(getBalance)`.
    public func getBalance(_ input: Operations.getBalance.Input) async throws -> Operations.getBalance.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getBalance.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/balance", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "units",
                    value: input.query.units
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBalance.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Balance.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Emulate sending message to blockchain
    ///
    /// - Remark: HTTP `POST /wallet/emulate`.
    /// - Remark: Generated from `#/paths//wallet/emulate/post(emulateMessageToWallet)`.
    public func emulateMessageToWallet(_ input: Operations.emulateMessageToWallet.Input) async throws
        -> Operations.emulateMessageToWallet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.emulateMessageToWallet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/wallet/emulate", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.emulateMessageToWallet.Output.Ok.Headers = .init(
                        Allowed_hyphen_By_hyphen_Battery: try converter.getRequiredHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Allowed-By-Battery",
                            as: Swift.Bool.self
                        ),
                        Supported_hyphen_By_hyphen_Battery: try converter.getRequiredHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Supported-By-Battery",
                            as: Swift.Bool.self
                        ),
                        Reject_hyphen_Reason: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Reject-Reason",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.emulateMessageToWallet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.emulateMessageToWallet.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Send message to blockchain
    ///
    /// - Remark: HTTP `POST /message`.
    /// - Remark: Generated from `#/paths//message/post(sendMessage)`.
    public func sendMessage(_ input: Operations.sendMessage.Input) async throws -> Operations.sendMessage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.sendMessage.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/message", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200: return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// verify an in-app purchase
    ///
    /// - Remark: HTTP `POST /purchase-battery/android`.
    /// - Remark: Generated from `#/paths//purchase-battery/android/post(androidBatteryPurchase)`.
    public func androidBatteryPurchase(_ input: Operations.androidBatteryPurchase.Input) async throws
        -> Operations.androidBatteryPurchase.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.androidBatteryPurchase.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/purchase-battery/android", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.androidBatteryPurchase.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AndroidBatteryPurchaseStatus.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /purchase-battery/ios/app-store-notification`.
    /// - Remark: Generated from `#/paths//purchase-battery/ios/app-store-notification/post(appStoreNotification)`.
    public func appStoreNotification(_ input: Operations.appStoreNotification.Input) async throws
        -> Operations.appStoreNotification.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.appStoreNotification.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/purchase-battery/ios/app-store-notification",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.appStoreNotification.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.appStoreResponse.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// verify an in-app purchase
    ///
    /// - Remark: HTTP `POST /purchase-battery/ios`.
    /// - Remark: Generated from `#/paths//purchase-battery/ios/post(iosBatteryPurchase)`.
    public func iosBatteryPurchase(_ input: Operations.iosBatteryPurchase.Input) async throws
        -> Operations.iosBatteryPurchase.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.iosBatteryPurchase.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/purchase-battery/ios", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.iosBatteryPurchase.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.iOSBatteryPurchaseStatus.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// charge battery with promo code
    ///
    /// - Remark: HTTP `POST /purchase-battery/promo-code`.
    /// - Remark: Generated from `#/paths//purchase-battery/promo-code/post(promoCodeBatteryPurchase)`.
    public func promoCodeBatteryPurchase(_ input: Operations.promoCodeBatteryPurchase.Input) async throws
        -> Operations.promoCodeBatteryPurchase.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.promoCodeBatteryPurchase.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/purchase-battery/promo-code", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.promoCodeBatteryPurchase.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.promoCodeBatteryPurchaseStatus.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `GET /purchase-battery/verify-purchase-promo`.
    /// - Remark: Generated from `#/paths//purchase-battery/verify-purchase-promo/get(verifyPurchasePromo)`.
    public func verifyPurchasePromo(_ input: Operations.verifyPurchasePromo.Input) async throws
        -> Operations.verifyPurchasePromo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.verifyPurchasePromo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/purchase-battery/verify-purchase-promo",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "promo",
                    value: input.query.promo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.verifyPurchasePromo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.verifyPurchasePromo.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns on-chain recharge methods.
    ///
    /// - Remark: HTTP `GET /recharge-methods`.
    /// - Remark: Generated from `#/paths//recharge-methods/get(getRechargeMethods)`.
    public func getRechargeMethods(_ input: Operations.getRechargeMethods.Input) async throws
        -> Operations.getRechargeMethods.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRechargeMethods.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/recharge-methods", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "include_recharge_only",
                    value: input.query.include_recharge_only
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRechargeMethods.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RechargeMethods.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /request-refund`.
    /// - Remark: Generated from `#/paths//request-refund/post(requestRefund)`.
    public func requestRefund(_ input: Operations.requestRefund.Input) async throws -> Operations.requestRefund.Output {
        try await client.send(
            input: input,
            forOperation: Operations.requestRefund.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/request-refund", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200: return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns a list of purchases made by a specific user.
    ///
    /// - Remark: HTTP `GET /purchases`.
    /// - Remark: Generated from `#/paths//purchases/get(getPurchases)`.
    public func getPurchases(_ input: Operations.getPurchases.Input) async throws -> Operations.getPurchases.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPurchases.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/purchases", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "include_gifts_on_the_way",
                    value: input.query.include_gifts_on_the_way
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPurchases.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Purchases.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// This method returns a list of transactions made by a specific user.
    ///
    /// - Remark: HTTP `GET /transactions`.
    /// - Remark: Generated from `#/paths//transactions/get(getTransactions)`.
    public func getTransactions(_ input: Operations.getTransactions.Input) async throws
        -> Operations.getTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/transactions", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transactions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /gasless/estimate-cost/{jetton_master}`.
    /// - Remark: Generated from `#/paths//gasless/estimate-cost/{jetton_master}/post(estimateGaslessCost)`.
    public func estimateGaslessCost(_ input: Operations.estimateGaslessCost.Input) async throws
        -> Operations.estimateGaslessCost.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.estimateGaslessCost.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/gasless/estimate-cost/{}",
                    parameters: [input.path.jetton_master]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "wallet_address",
                    value: input.query.wallet_address
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "wallet_public_key",
                    value: input.query.wallet_public_key
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.estimateGaslessCost.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GaslessEstimation.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /restricted/create-custom-refund`.
    /// - Remark: Generated from `#/paths//restricted/create-custom-refund/post(createCustomRefund)`.
    public func createCustomRefund(_ input: Operations.createCustomRefund.Input) async throws
        -> Operations.createCustomRefund.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createCustomRefund.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/restricted/create-custom-refund", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token",
                    value: input.query.token
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createCustomRefund.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.createCustomRefund.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /restricted/users/{user_id}/reset-balance`.
    /// - Remark: Generated from `#/paths//restricted/users/{user_id}/reset-balance/post(resetUserBalance)`.
    public func resetUserBalance(_ input: Operations.resetUserBalance.Input) async throws
        -> Operations.resetUserBalance.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.resetUserBalance.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/restricted/users/{}/reset-balance",
                    parameters: [input.path.user_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token",
                    value: input.query.token
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.resetUserBalance.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.resetUserBalance.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `POST /restricted/purchases/{purchase_id}/extend-refund-period`.
    /// - Remark: Generated from `#/paths//restricted/purchases/{purchase_id}/extend-refund-period/post(extendRefundPeriod)`.
    public func extendRefundPeriod(_ input: Operations.extendRefundPeriod.Input) async throws
        -> Operations.extendRefundPeriod.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.extendRefundPeriod.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/restricted/purchases/{}/extend-refund-period",
                    parameters: [input.path.purchase_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token",
                    value: input.query.token
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.extendRefundPeriod.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.extendRefundPeriod.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// - Remark: HTTP `GET /jetton-metadata/{name}.json`.
    /// - Remark: Generated from `#/paths//jetton-metadata/{name}.json/get(getJettonMetadata)`.
    public func getJettonMetadata(_ input: Operations.getJettonMetadata.Input) async throws
        -> Operations.getJettonMetadata.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getJettonMetadata.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/jetton-metadata/{}.json",
                    parameters: [input.path.name]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJettonMetadata.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getJettonMetadata.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
}
